/**
***  IMNBL32.C          Win32 DLL providing NetBIOS Services for 32-bit Windmill
***
***  (C) Copyright Windmill Software Ltd. 1994-96. All rights reserved.
***
***  Documentation: See project IMNBLIB
***
***
***  This DLL provides a set of services to 16-bit Windows applications which
***  allow them to use a subset of NetBIOS Network API. The principal use
***  is for IMNETB.EXE - the driver which allows Windmill and Streamer to
***  communicate with Network Microlinks (ML3200 & ML600 series) over
***  Ethernet. It could also be used for other apps and other types of
***  network, though they must require only the subset of NetBIOS implemented
***  here.
***
***     FOR DETAILS - READ  IMNBLIB-FS 2.0    (August 1996)
***
***  Note that this DLL includes an INTERRUPT HANDLER, for picking up the
***  software interrupts generated by NetBIOS when an asynchronous operation
***  completes. These are translated into messages posted to the message
***  queue of the calling app's window. This means that this code segment
***  MUST be FIXED in memory, and all memory buffers used for data transfer
***  must also be FIXED and non-pagable.
***
***  For a discussion of this technique, and of using NetBIOS under Windows
***  generally, see:
***
***     Microsoft Systems Journal - August 1992
***
***  For details of NetBIOS itself see:
***
***     IBM NetBIOS Application Development Guide  (IBM part no 68X2270)
***
***     "C Programmer's Guide to NetBIOS, IPX and SPX" by W.D.Schwaderer
***         Sams Publishing 1992.  ISBN 0672300508
***
***
***	 For details of using NetBIOS under 32-bit versions of Windows (eg. Win NT)
***  see the documentation for function "Netbios" in Win32 Software Development Kit.
***
***  Associated files:
***
***     IMNBLIB.H       Constants & prototypes - include in all calling Apps
***     IMNBIOS.H       NetBIOS structures & constants - private use only
***     IMNBLIB.RC      VersionInfo structure for version stamping
***     IMNBLIB.DEF     Linker definitions file (Exports etc)
***     IMNBLIB.MAK     Makefile for Microsoft Visual C++ 1.5
***
***  History:
***
***  July 1994   Stuart Grace    Created for version 1.00, according to IMNBLIB-FS 1.0.
***
***   Aug 1996   Stuart Grace    Extended for ver 2.00, adding group names and datagrams.
***								  See IMNBLIB-FS 2.0.
***
***   Oct 1996   Stuart Grace	 Ported to 32-bits as IMNBL32.DLL for Win32 apps.
**/




#define STRICT          /* Enforce proper type checking */

#define NOCOMM			// Speed up compilation
#define NOGDI

#include <windows.h>
#include <windowsx.h>   /* for GlobalAllocPtr etc. */

#include <stdlib.h>


#include "imnblib.h"    /* constants and prototypes */
#include "imnbios.h"    /* NCB structure etc */






/**  Library version control string
**/

static char *szVersionString = "6.00";





/**  The following structures are defined in IMNBIOS.H
**/

NETUSER  NetUser [ MAX_USERS ];         /* Details of each user */

NETOP    NetOp [ MAX_OPS ];             /* Pending NCBs         */



/**  Globals used for the debugging feature:
***
***     nDebugMode = 0    (Default) normal operation - no debug output
***
***     nDebugMode = 1    Details of every call into library and every return
***                         code are sent to the Debug window.
**/

static short   nDebugMode;     	/* global set by IMNBSetMode function */

static char    szDebugTxt [ 80 ];




/**  Prototypes for our internal functions used only within this file, or called-back by Windows
**/

void CALLBACK  NetBIOSIntHandler ( PNCB NetCtrlBlock );

void  ShowDebugText    ( LPCSTR szText );
short ShowDebugRetCode ( short nCode );

void  TranslateCNameToNB ( LPCSTR lpszCName,  LPSTR lpszNBName );
void  TranslateNBNameToC ( LPCSTR lpszNBName, LPSTR lpszCName  );

short FindNetCtrlBlock ( short nUser, short *pnOp );
BOOL  ValidateOpNumber ( short nOp, WORD wType );

short SubmitOperationToNetBIOS ( short nOp );





//  This is called when the DLL is first loaded into memory (before the app makes any
//  calls) and again when it is being unloaded. The dwReason value indicates which is which.
//
//

int APIENTRY DllMain ( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )

{
	short	nIndex;


	switch ( dwReason ) {
	
	  case DLL_PROCESS_ATTACH :		// DLL is being loaded by a new app

		nDebugMode = 0;         /* debug trace output off */

		// Initialise all NetUser structs

		for ( nIndex = 0 ; nIndex < MAX_USERS ; nIndex++ ) {

			NetUser [ nIndex ].nStatus    = USER_FREE;     /* no owner */
			NetUser [ nIndex ].hWndNotify = NULL;          /* no window */
		}

		// Initialise all NetOp structs

		for ( nIndex = 0 ; nIndex < MAX_OPS ; nIndex++ ) {

			NetOp [ nIndex ].nUser = OP_NOT_IN_USE;       /* not going */
		}

		break;

	  case DLL_PROCESS_DETACH :		// App is closing down

		ShowDebugText ( "\nIMNB Detach \n" );
		break;

	  default: break;

	}

	return ( 1 );   // OK
}





/**	IMNBGetVersion ()
***
***  This function returns the version number of the library. It also copies
***  the version string into the buffer provided if it is not NULL.
**/

short _declspec (dllexport)  WINAPI IMNBGetVersion ( LPSTR lpszVersion, short nMaxChars )
{

	if ( lpszVersion != NULL ) {

		/** We have been supplied with a buffer for the version info so copy it in.
		***
		*** Check the version string will fit. If not then just copy
		*** upto max chars.
		**/

		if ( nMaxChars > (short) strlen ( szVersionString ) ) {

			lstrcpy ( lpszVersion, szVersionString );

		} else {

			_fstrncpy ( lpszVersion, szVersionString, nMaxChars - 1 );

			lpszVersion [ nMaxChars - 1 ] = '\0';
		}
	}	


	/** The major version number is the first character of the string.
	**/

	return ( (short) ( szVersionString [ 0 ] - '0' ) );
}







/**	IMNBSetMode ()
***
***  This turns on/off the debug trace output.
**/

short _declspec (dllexport)  WINAPIIMNBSetMode ( short nMode )
{

	switch ( nMode ) {

          case 0 :  ShowDebugText ( "\nIMNB Mode 0\n" );
                	nDebugMode = 0;
                    break;

          case 1 :  nDebugMode = 1;
                    ShowDebugText ( "\nIMNB Mode 1\n" );
                	break;

          default : ShowDebugText ( "\nIMNB Unsupported Mode!\n" );
	               	return ( IMNB_BAD_MODE );
	}	

	return ( OK );
}






/**  IMNBRegisterName. This initiates a NetBIOS ADDNAME command, to put a
***  new name in the local name table.
***
***  Args supplied by caller are:
***		- LANA number (determines which network adapter to use - normally 0)
***			If nLan is 0..255, it creates a UNIQUE name on this LANA.
***			If nLan is IMNB_GROUP_NAME + N, it creates a GROUP name on LANA "N".
***			 (Group names can only be used with datagrams, not with sessions).
***		- a system-wide unique name (1..15 chars),
***     - hWnd of calling app's window (to receive message when finished)
***     - the wMsg value to be used for this message (e.g. WM_USER+1 )
***  	- a pointer to a short which will receive the operation number.
***
***  This function returns as soon as the operation is underway, but the
***  process can take several seconds to complete. The specified message
***  will be sent when the operation completes - either success or failure.
***  Alternatively, the caller could repeatedly poll IMNBFinishRegistration
***  but this wastes CPU time.
***
***  NOTE: The specified hWnd and wMsg values will be used for ALL future
***        notifications relating to this user.
***
***  For usage notes, read the IMNBLIB Functional Spec.
***  For details of error returns, see IBM NetBIOS App. Development Guide.
**/

short _declspec (dllexport)  WINAPI IMNBRegisterName ( short nLAN, LPCSTR lpszMyName, HWND hWnd,
                                              				UINT wMsg, short  *lpnOpNum )
{
	short	nIndex, nCode, nCheck, nOp;
	BOOL	bResetNeeded;



	ShowDebugText ( "\nIMNB Register " );


	*lpnOpNum = BAD_OP_NUM;        	 /* op NOT running yet */


	/** Parameter validation: hWnd should either be NULL or a valid
	***  window handle. lpszMyName must point to readable bytes and
	***  lpnOpNum must point to 2 writable bytes.
	**/

    if ( ( hWnd != NULL ) && ( !IsWindow ( hWnd ) ) ) {

		return ( ShowDebugRetCode ( IMNB_BAD_WINDOW ) );
    }


	if ( IsBadReadPtr ( lpszMyName, 2 ) ||
         IsBadWritePtr ( lpnOpNum, 2 ) ) {

    	return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }


    ShowDebugText ( lpszMyName );     /* Display name (for debugging) */


    // Now find a free user number (if any left).
	
	for ( nIndex = 0 ; nIndex < MAX_USERS ; nIndex++ ) {

		if ( NetUser [ nIndex ].nStatus == USER_FREE ) {

			break;  /* use this one */
		}

        if ( nIndex == ( MAX_USERS - 1 ) ) {

			return ( ShowDebugRetCode ( IMNB_TOO_MANY_USERS ) );
        }
	}


	// Found a free user number - now prepare an NCB:

	nCode = FindNetCtrlBlock ( nIndex, &nOp );

	if ( nCode != OK ) {

		return ( ShowDebugRetCode ( nCode ) ); 	   // no memory
    }


    /** Store caller's details with the user number:
    **/

	TranslateCNameToNB ( lpszMyName, NetUser [ nIndex ].szName );

	( NetUser [ nIndex ].szName )[ 16 ] = 0;    // term for sprintf etc

	NetUser [ nIndex ].nStatus     = USER_REGISTERING;
	NetUser [ nIndex ].hWndNotify  = hWnd;
	NetUser [ nIndex ].wNotifyMsg  = wMsg;

	if ( nLAN >= IMNB_GROUP_NAME ) {		// Ignore group name flag if set
	
    	NetUser [ nIndex ].nLanAdapter = nLAN - IMNB_GROUP_NAME;		// Extract LANA number
	} else {
    	NetUser [ nIndex ].nLanAdapter = nLAN;
	}


	// The 16-bit versions of Windows maintain a single set of NetBIOS internal tables which
	// are initialised by the system. The 32-bit versions create a "new" NetBIOS emulation for each
	// process, and these must be initialised by us before we can use them. One NetBIOS RESET
	// command is required for each LANA that we want to use.
	//
	// If the LANA requested by this new user has already been reset, we must not reset it again.
	// Otherwise, we need a SYNCHRONOUS call with the RESET command.

	bResetNeeded = TRUE;

	for ( nCheck = 0 ; nCheck < MAX_USERS ; nCheck++ ) {

		if ( nCheck == nIndex ) {		// Don't check our own structure!!
			continue;
		}

		if ( NetUser [ nCheck ].nStatus != USER_FREE ) {		// This structure is in use

	    	if ( NetUser [ nCheck ].nLanAdapter == NetUser [ nIndex ].nLanAdapter ) {

				bResetNeeded = FALSE;	// This same LAN number has already been reset
			}
        }
	}


	if ( bResetNeeded ) {

	    /** Fill required fields of NCB for SYNCHRONOUS RESET cmnd:
	    ***
	    ***   COMMAND, LANA
	    ***
	    *** This command is synchronous - will wait for completion before
	    *** returning from SubmitOperationToNetBIOS. No post callback.
	    **/

	    NetOp [ nOp ].ncb_command  = NCBRESET;
		NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nIndex ].nLanAdapter;
	    NetOp [ nOp ].ncb_post     = (DWORD) 0;       /* no post interrupt */

	    nCode = SubmitOperationToNetBIOS ( nOp );

	    if ( nCode != OK ) {  		/* command rejected by NetBIOS? */

	   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

    		return ( ShowDebugRetCode ( nCode ) );
		}

	    memset ( &( NetOp [ nOp ].ncb_command ), 0, NUM_BYTES_IN_NCB );		// erase NCB
	}


	// Fill required fields in NCB for asynchronous ADD NAME cmnd:
	//
	//    COMMAND, LANA, NAME and POST_ADDR

	if ( nLAN >= IMNB_GROUP_NAME ) {		// Is a group name required?
	
		NetOp [ nOp ].ncb_command  = ( NCB_ASYNCH | NCB_ADDGRNAME );	// Use ADD GROUP NAME cmnd
	} else {
		NetOp [ nOp ].ncb_command  = ( NCB_ASYNCH | NCB_ADDNAME );		// Use ADD NAME cmnd
	}

	NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nIndex ].nLanAdapter;
    NetOp [ nOp ].ncb_post     = (DWORD) NetBIOSIntHandler;

    strncpy ( NetOp [ nOp ].ncb_name, NetUser [ nIndex ].szName, 16 );

    NetOp [ nOp ].wParam = IMNB_REGISTER;       /* type of notify msg */


    nCode = SubmitOperationToNetBIOS ( nOp );


	if ( nCode == OK ) {    	/* command accepted by NetBIOS */

		*lpnOpNum = nOp;        /* this is operation number */

	} else {    			/* command rejected by NetBIOS */

		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

		NetUser [ nIndex ].nStatus    = USER_FREE;  /* free NetUser */
		NetUser [ nIndex ].hWndNotify = NULL;
	}

	return ( ShowDebugRetCode ( nCode ) );
}





/**  The completion function for a registration started above. See comments
***  above. See also IMNBLIB-FS and NetBIOS App Development Guide..
**/

short _declspec (dllexport)  WINAPI IMNBFinishRegistration ( short nOpNum, short  *lpnNetUser )
{
	short   nCode, nUser;



	ShowDebugText ( "\nIMNB FinishReg" );



	// Parameter validation: must have a valid REG op number and a ptr to 2 writable bytes

    if ( ValidateOpNumber ( nOpNum, IMNB_REGISTER ) == FALSE ) {

		return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
	}

	if ( IsBadWritePtr ( lpnNetUser, 2 ) ) {

		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
	}


    nUser = NetOp [ nOpNum ].nUser;         /* find NetUser struct */


    // Has this operation finished yet? Check NCB command complete flag

	if ( NetOp [ nOpNum ].ncb_cmd_cplt == (BYTE) 0xFF ) {

		ShowDebugText ( " - still pending" );

		return ( IMNB_OP_IN_PROGRESS );     /* not yet ready */
	}


	nCode = NetOp [ nOpNum ].ncb_retcode;    /* get NetBIOS return code */

	if ( nCode == OK ) {            /* Successfully registerd */

		*lpnNetUser = nUser;    /* This is proper active user now */

        NetUser [ nUser ].nNameNumber = NetOp [ nOpNum ].ncb_num;
        NetUser [ nUser ].nStatus     = USER_ACTIVE;

	} else {                /* Failed to register */

		nCode += IMNB_ERROR_BASE;     /* adjust to IMNB err code */

		*lpnNetUser = BAD_OP_NUM;              /* No user number assigned */

		NetUser [ nUser ].nStatus    = USER_FREE;     /* no user */
		NetUser [ nUser ].hWndNotify = NULL;          /* no window */
	}

	NetOp [ nOpNum ].nUser = OP_NOT_IN_USE;        /* release NCB */

	return ( ShowDebugRetCode ( nCode ) );
}





/**  IMNBListenForClient. This starts a NetBIOS LISTEN command. Caller may
***  specify one particular name to accept, or if this is NULL anyone calling
***  to this name will be accepted. The timeout values specified here will
***  apply to all DATA transfers using the resulting session. There is no
***  time limit to this - it will listen until either a call is received or
***  the operation is cancelled by IMNBCancelOp. Caller should trap the
***  notification message (or poll IMNBFinishListen) to find out when a call
***  has been received.
***
***  As always - read IMNBLIB-FS and NetBIOS App Development Guide.
**/

short _declspec (dllexport)  WINAPI IMNBListenForClient ( short nNetUser, LPCSTR lpszClientName,
               					 	short nRecTimeOut, short nSendTimeOut, short  *lpnOpNum )
{
	short	      nCode;
    static short  nOp;



	ShowDebugText ( "\nIMNB Listen for " );


    *lpnOpNum = BAD_OP_NUM;        	 /* op NOT running yet */



    /** Parameter validation: should have a valid, active user no;
    *** either NULL or readable name string, and ptr to 2 writable bytes.
    **/

    if ( lpszClientName == NULL ) {

		ShowDebugText ( "anyone" );       /* NULL client name --> ANY */

    } else {

    	if ( IsBadReadPtr ( lpszClientName, 2 ) ) {

   			return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    	}

        ShowDebugText ( lpszClientName );
    }


    if ( ( nNetUser < 0 ) || ( nNetUser > MAX_USERS ) ) {

		return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( NetUser [ nNetUser ].nStatus != USER_ACTIVE ) {

		return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( IsBadWritePtr ( lpnOpNum, 2 ) ) {

   		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }


    ShowDebugText ( " by " );
    ShowDebugText ( NetUser [ nNetUser ].szName );   /* our server name */


	/** Obtain an NCB:
	**/

    nCode = FindNetCtrlBlock ( nNetUser, &nOp );

    if ( nCode != OK ) {

            return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    /** Fill required fields of NCB for asynchronous LISTEN cmnd:
    ***
    ***    COMMAND, LANA_NUM, NAME (our own), RTO, STO,
    ***    CALLNAME (clients's or * for anyone), and POST_ADDR
    **/

    NetOp [ nOp ].ncb_command  = ( NCB_ASYNCH | NCB_LISTEN );
    NetOp [ nOp ].ncb_post     = (DWORD) NetBIOSIntHandler;
    NetOp [ nOp ].ncb_rto      = (BYTE) nRecTimeOut;
    NetOp [ nOp ].ncb_sto      = (BYTE) nSendTimeOut;
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nNetUser ].nLanAdapter;

    strncpy ( NetOp [ nOp ].ncb_name, NetUser [ nNetUser ].szName, 16 );


    if ( lpszClientName == NULL ) {

		// User has not given us a specific client name. We will give NetBIOS the
		// callname "*" which means accept calls from any client.

    	TranslateCNameToNB ( "*", NetOp [ nOp ].ncb_callname );

    } else {        /* accept specified client only */

    	TranslateCNameToNB ( lpszClientName, NetOp [ nOp ].ncb_callname );
    }

    NetOp [ nOp ].wParam = IMNB_LISTEN;       /* type of notify msg */

    nCode = SubmitOperationToNetBIOS ( nOp );

    if ( nCode == OK ) {    	/* command accepted by NetBIOS */

   		*lpnOpNum = nOp;        	/* this is operation number */

    } else {    			/* command rejected by NetBIOS */

   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */
    }

	return ( ShowDebugRetCode ( nCode ) );
}






/**  The function to get status & results for a LISTEN started by function
***  above. See comments above.
**/

short _declspec (dllexport)  WINAPI IMNBFinishListen ( short nOpNum, short  *lpnSession, LPSTR lpszClientName )
{
    short   	nCode, nUser;
    static char	szTemp [ 20 ];



    ShowDebugText ( "\nIMNB FinishLsn " );



    /** Parameter validation: must have a valid LISTEN op number, a
    *** ptr to 2 writable bytes for session number, and either NULL
    *** or ptr to 17 writable bytes for client name.
    **/

    if ( ValidateOpNumber ( nOpNum, IMNB_LISTEN ) == FALSE ) {

		return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }

	if ( IsBadWritePtr ( lpnSession, 2 ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }

    if ( lpszClientName != NULL ) {

		if ( IsBadWritePtr ( lpszClientName, 17 ) ) {
	
        	return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
        }
    }


    nUser = NetOp [ nOpNum ].nUser;         /* find NetUser struct */


    /** Has this operation finished yet? Check NCB command complete flag
    **/

    if ( NetOp [ nOpNum ].ncb_cmd_cplt == (BYTE) 0xFF ) {

        ShowDebugText ( "- still pending" );

        return ( IMNB_OP_IN_PROGRESS );     /* not yet ready */
    }


    nCode = NetOp [ nOpNum ].ncb_retcode;     /* get NetBIOS return code */

    if ( nCode == OK ) {            /* Successfully connected */

        *lpnSession = NetOp [ nOpNum ].ncb_lsn;    /* session number */

        if ( lpszClientName != NULL ) {

			TranslateNBNameToC ( NetOp [ nOpNum ].ncb_callname, lpszClientName );
        }

        if ( nDebugMode > 0 ) {

			// If debugging output is enabled, report who has just called to whom.

            TranslateNBNameToC ( NetOp [ nOpNum ].ncb_callname, szTemp );

            wsprintf ( szDebugTxt, "%s called by %s (sess %d)", (LPCSTR) NetUser [ nUser ].szName,
                   		   											(LPCSTR) szTemp, *lpnSession );

        	ShowDebugText ( szDebugTxt );
        }

	} else {                /* Failed to connect */

		nCode += IMNB_ERROR_BASE;      /* adjust to IMNB err code */

        *lpnSession = BAD_SESSION_NUM;  /* NOT valid session number */
    }

	NetOp [ nOpNum ].nUser = OP_NOT_IN_USE;        /* release NCB */

    return ( ShowDebugRetCode ( nCode ) );
}





/**  This asks NetBIOS to CALL to another named device on the network. This
***  target device must have a LISTEN in progress in order to accept the
***  call. The timeout values specified here will apply to all DATA transfers
***  using the resulting session. If the named target is not found or is not
***  listening, the call times out after a couple of seconds. User must
***  call IMNBFinishCall to find out results.
**/

short _declspec (dllexport)  WINAPI IMNBCallServer ( short nNetUser, LPCSTR lpszServerName, short nRecTimeOut,
                                            				short nSendTimeOut, short  *lpnOpNum )
{
	short	      nCode;
    static short  nOp;



    ShowDebugText ( "\nIMNB Call from " );


    *lpnOpNum = BAD_OP_NUM;        	 /* op NOT running yet */



    /** Parameter validation: should have a valid, active user no;
    *** a readable name string, and ptr to 2 writable bytes.
    **/

    if ( ( nNetUser < 0 ) || ( nNetUser > MAX_USERS ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( NetUser [ nNetUser ].nStatus != USER_ACTIVE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( IsBadReadPtr ( lpszServerName, 2 ) ||
         IsBadWritePtr ( lpnOpNum, 2 ) ) {

   		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }


    ShowDebugText ( NetUser [ nNetUser ].szName );   /* our client name */
    ShowDebugText ( " to " );
    ShowDebugText ( lpszServerName );


	// Obtain an NCB & Op number:

    nCode = FindNetCtrlBlock ( nNetUser, &nOp );

    if ( nCode != OK ) {

        return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    /** Fill required fields of NCB for asynchronous CALL cmnd:
    ***
    ***    COMMAND, LANA_NUM, NAME (our own), RTO, STO,
    ***    CALLNAME (server's), and POST_ADDR
    **/

    NetOp [ nOp ].ncb_command  = ( NCB_ASYNCH | NCB_CALL );
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nNetUser ].nLanAdapter;
    NetOp [ nOp ].ncb_post     = (DWORD) NetBIOSIntHandler;
    NetOp [ nOp ].ncb_rto      = (BYTE) nRecTimeOut;
    NetOp [ nOp ].ncb_sto      = (BYTE) nSendTimeOut;

    _fstrncpy ( NetOp [ nOp ].ncb_name, NetUser [ nNetUser ].szName, 16 );

   	TranslateCNameToNB ( lpszServerName, NetOp [ nOp ].ncb_callname );

    NetOp [ nOp ].wParam = IMNB_CALL;         /* type of notify msg */


    nCode = SubmitOperationToNetBIOS ( nOp );

    if ( nCode == OK ) {    	/* command accepted by NetBIOS */

   		*lpnOpNum = nOp;        	/* this is operation number */

    } else {    			/* command rejected by NetBIOS */

        NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */
    }

	return ( ShowDebugRetCode ( nCode ) );
}





/**  This gets results from a CALL operation started by IMNBCallServer.
***
**/

short _declspec (dllexport)  WINAPI IMNBFinishCall ( short nOpNum, short  *lpnSession )
{
    short   nCode;



    ShowDebugText ( "\nIMNB FinishCall " );



    /** Parameter validation: must have a valid CALL op number and a
    *** ptr to 2 writable bytes for session number.
    **/

    if ( ValidateOpNumber ( nOpNum, IMNB_CALL ) == FALSE ) {

            return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }

	if ( IsBadWritePtr ( lpnSession, 2 ) ) {

            return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }



    /** Has this operation finished yet? Check NCB command complete flag
    **/

    if ( NetOp [ nOpNum ].ncb_cmd_cplt == (BYTE) 0xFF ) {

        ShowDebugText ( "- still pending" );

        return ( IMNB_OP_IN_PROGRESS );     /* not yet ready */
    }


    nCode = NetOp [ nOpNum ].ncb_retcode;     /* get NetBIOS return code */

    if ( nCode == OK ) {            /* Successfully connected */

        *lpnSession = NetOp [ nOpNum ].ncb_lsn;    /* session number */

        if ( nDebugMode > 0 ) {

            wsprintf ( szDebugTxt, "created sess %d", *lpnSession );
            ShowDebugText ( szDebugTxt );
        }

	} else {                	/* Failed to connect */

         nCode += IMNB_ERROR_BASE;      /* adjust to IMNB err code */

        *lpnSession = BAD_SESSION_NUM;  /* NOT valid session number */
    }

	NetOp [ nOpNum ].nUser = OP_NOT_IN_USE;        /* release NCB */

    return ( ShowDebugRetCode ( nCode ) );
}






/**  This starts waiting for an incoming data block on the specified session
***  using the NetBIOS RECEIVE command. If the session number is set to
***  IMNB_ANY_SESSION, it uses RECEIVE_ANY to accept data from any session
***  with our name. Timeout period (if any) was set when the session was
***  established using Call or Listen.
***
***  This function uses GlobalAllocPtr to create a FIXED page-locked buffer
***  large enough to hold the biggest expected block (given in wMaxSize).
***  Returns IMNB_OUT_OF_MEMORY if GlobalAlloc fails. When the notification
***  message is sent, the app calls IMNBFinishReceive to find out what (if
***  anything) arrived, and to copy it out into a user supplied buffer. At
***  that point, IMNBFinishReceive will free the allocated buffer.
***
***  The receive op may be cancelled at any time (using IMNBCancelOp), but
***  you MUST still call IMNBFinishReceive afterwards to free the buffer and
***  the Net Control Block.
**/

short _declspec (dllexport)  WINAPI IMNBReceiveData ( short nNetUser, short nSession, WORD wMaxSize,
																			 short  *lpnOpNum )
{
	short	      nCode;
    void          * lpvBuffer;
    static short  nOp;



    ShowDebugText ( "\nIMNB Recv" );


    *lpnOpNum = BAD_OP_NUM;        	 /* op NOT running yet */



    // Parameter validation: should have a valid, active user no and ptr to 2 writable bytes.

    if ( ( nNetUser < 0 ) || ( nNetUser > MAX_USERS ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( NetUser [ nNetUser ].nStatus != USER_ACTIVE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( IsBadWritePtr ( lpnOpNum, 2 ) ) {

   		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }


    if ( nDebugMode > 0 ) {         /* show debug info if requested */

        if ( nSession == IMNB_ANY_SESSION ) {

    		ShowDebugText ( "Any by " );
    	} else {

            wsprintf ( szDebugTxt, " from sess %d by ", nSession);
    		ShowDebugText ( szDebugTxt );
    	}

    	ShowDebugText ( NetUser [ nNetUser ].szName );
    }


    /** Obtain an NCB & Op number:
	**/

    nCode = FindNetCtrlBlock ( nNetUser, &nOp );

    if ( nCode != OK ) {

        return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    // Allocate a buffer to receive the data

    lpvBuffer = GlobalAllocPtr ( ( GMEM_FIXED | GMEM_ZEROINIT ), (DWORD) wMaxSize );

    if ( lpvBuffer == NULL ) {

   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

        ShowDebugText ( " - Failed to create data buf" );

    	return ( IMNB_OUT_OF_MEMORY );    /* no memory for buffer! */
    }


	/** Fill required fields of NCB:
    ***
    ***   For asynchronous RECEIVE_ANY:
    ***
    ***      COMMAND, LANA_NUM, NUM (our name number), BUFFER (ptr),
    ***      LENGTH (of buffer), and POST_ADDR
    ***
    ***   For asynchronous RECEIVE for one given session:
    ***
    ***      COMMAND, LANA_NUM, LSN (session number), BUFFER (ptr),
    ***      LENGTH (of buffer), and POST_ADDR
    **/

    if ( nSession == IMNB_ANY_SESSION ) {

    	NetOp [ nOp ].ncb_command = ( NCB_ASYNCH | NCB_RECVANY );
    	NetOp [ nOp ].ncb_num     = (BYTE) NetUser [ nNetUser ].nNameNumber;

    } else {        /* specific session */

    	NetOp [ nOp ].ncb_command = ( NCB_ASYNCH | NCB_RECV );
    	NetOp [ nOp ].ncb_lsn     = (BYTE) nSession;
    }

    NetOp [ nOp ].ncb_post     = (DWORD) NetBIOSIntHandler;
    NetOp [ nOp ].ncb_buffer   = lpvBuffer;
    NetOp [ nOp ].ncb_length   = wMaxSize;
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nNetUser ].nLanAdapter;

    NetOp [ nOp ].wParam = IMNB_RECEIVE;       /* type of notify msg */


    nCode = SubmitOperationToNetBIOS ( nOp );

    if ( nCode == OK ) {    	/* command accepted by NetBIOS */

   		*lpnOpNum = nOp;        	/* this is operation number */

    } else {    			/* command rejected by NetBIOS */

   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

    	GlobalFreePtr ( lpvBuffer );       /* free the data buffer */
    }

	return ( ShowDebugRetCode ( nCode ) );
}






/**  SEE FUNCTION ABOVE.
***
**/

short _declspec (dllexport)  WINAPI IMNBFinishReceive ( short nOpNum, LPVOID lpvBuffer, LPWORD lpwActualSize,
					       															short  *lpnSession )
{
    short         nCode, nUser;



    ShowDebugText ( "\nIMNB FinishRecv " );



    /** Parameter validation: must have a valid RECV op number; a
    *** ptr to writable bytes for data buffer; ptr to 2 writable bytes
    *** for actual size; and ptr to 2 writable bytes for session number
    *** (unless NULL).
    **/

    if ( ValidateOpNumber ( nOpNum, IMNB_RECEIVE ) == FALSE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }

	if ( IsBadWritePtr ( lpvBuffer, 1 ) ||
         IsBadWritePtr ( lpwActualSize, 2 ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }

    if ( lpnSession != NULL ) {

    	if ( IsBadWritePtr ( lpnSession, 2 ) ) {

        	return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    	}
    }


    /** Has this operation finished yet? Check NCB command complete flag
    **/

    if ( NetOp [ nOpNum ].ncb_cmd_cplt == (BYTE) 0xFF ) {

        ShowDebugText ( "- still pending" );

        return ( IMNB_OP_IN_PROGRESS );     /* not yet ready */
    }


    nCode = NetOp [ nOpNum ].ncb_retcode;       /* get NetBIOS ret code */

    *lpwActualSize = NetOp [ nOpNum ].ncb_length;   /* amount data recd */

    if ( lpnSession != NULL ) {

        *lpnSession = NetOp [ nOpNum ].ncb_lsn;      /* session num */
    }


    // Copy the received data out of the buffer used by NetBIOS into the
    // user's buffer, then free the NetBIOS buffer.

    memcpy ( lpvBuffer, NetOp [ nOpNum ].ncb_buffer, *lpwActualSize );

    GlobalFreePtr ( NetOp [ nOpNum ].ncb_buffer );


    /** If debugging mode selected, display some info about results
    **/

    if ( nDebugMode > 0 ) {

    	if ( lpnSession != NULL ) {

	        wsprintf ( szDebugTxt, "sess %d ", *lpnSession );

        	ShowDebugText ( szDebugTxt );
		}

        nUser = NetOp [ nOpNum ].nUser;

        wsprintf ( szDebugTxt, "got %u bytes for %s", *lpwActualSize, (LPCSTR) NetUser [ nUser ].szName );

        ShowDebugText ( szDebugTxt );
	}

    if ( nCode != OK ) {

        nCode += IMNB_ERROR_BASE;     /* adjust to IMNB err code */
    }

	NetOp [ nOpNum ].nUser = OP_NOT_IN_USE;        /* release NCB */

    return ( ShowDebugRetCode ( nCode ) );
}





/**  IMNBSendData is the partner to IMNBReceiveData. Caller must supply the
***  session number (returned by Listen or Call), pointer to the memory
***  buffer to be sent, and a size (1 byte to 64K). Since the transfer
***  actually happens in the background, this function uses GlobalAllocPtr to
***  create its own fixed, page-locked copy of the data. This ensures the data
***  is safely locked down even if the app destroys the original copy before
***  transfer is complete. App MUST therefore make a call to IMNBFinishSend,
***  not only to get the completion code, but also to free the local copy.
***  Timeout for the send was set when the session was established. Returns
***  IMNB_OUT_OF_MEMORY if GlobalAlloc fails.
**/

short _declspec (dllexport)  WINAPI IMNBSendData ( short nNetUser, short nSession, LPVOID lpvBuffer, WORD wSize,
					  																short  *lpnOpNum )
{
	short	      nCode;
    void          * lpvPrivateBuf;
    static short  nOp;


    ShowDebugText ( "\nIMNB Send" );


    *lpnOpNum = BAD_OP_NUM;        	 /* op NOT running yet */



    /** Parameter validation: should have a valid, active user no,
    *** ptr to wSize readable bytes and ptr to 2 writable bytes.
    **/

    if ( ( nNetUser < 0 ) || ( nNetUser > MAX_USERS ) ) {

            return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( NetUser [ nNetUser ].nStatus != USER_ACTIVE ) {

            return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( IsBadWritePtr ( lpnOpNum, 2 ) ||
         IsBadReadPtr ( lpvBuffer, wSize ) ) {

   		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }


    if ( nDebugMode > 0 ) {         /* Display info if debugging */

            wsprintf ( szDebugTxt, " %u bytes to sess %d by %s", wSize,
                         nSession, (LPCSTR) NetUser [ nNetUser ].szName );

            ShowDebugText ( szDebugTxt );
	}


	// Obtain an NCB:

    nCode = FindNetCtrlBlock ( nNetUser, &nOp );

    if ( nCode != OK ) {

            return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    // Allocate a buffer to hold the data. If this is OK, copy the users data into it.

    lpvPrivateBuf = GlobalAllocPtr ( ( GMEM_FIXED | GMEM_ZEROINIT ), (DWORD) wSize );

    if ( lpvPrivateBuf == NULL ) {

   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

        ShowDebugText ( " - Failed to create data buf" );

    	return ( IMNB_OUT_OF_MEMORY );    /* no memory for buffer! */
    }

	memcpy ( lpvPrivateBuf, lpvBuffer, wSize );



	/** Fill required fields of NCB for asynchronous SEND:
    ***
    ***      COMMAND, LANA_NUM, LSN (session number), BUFFER (ptr),
    ***      LENGTH (of buffer), and POST_ADDR
    **/

   	NetOp [ nOp ].ncb_command  = ( NCB_ASYNCH | NCB_SEND );
   	NetOp [ nOp ].ncb_lsn      = (BYTE) nSession;
    NetOp [ nOp ].ncb_post     = (DWORD) NetBIOSIntHandler;
    NetOp [ nOp ].ncb_buffer   = lpvPrivateBuf;
    NetOp [ nOp ].ncb_length   = wSize;
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nNetUser ].nLanAdapter;

    NetOp [ nOp ].wParam = IMNB_SEND;         /* type of notify msg */


    nCode = SubmitOperationToNetBIOS ( nOp );

    if ( nCode == OK ) {    	/* command accepted by NetBIOS */

   		*lpnOpNum = nOp;        	/* this is operation number */

    } else {    			/* command rejected by NetBIOS */

        NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

    	GlobalFreePtr ( lpvPrivateBuf );    /* free the data buffer */
    }

	return ( ShowDebugRetCode ( nCode ) );
}




/**  SEE FUNCTION ABOVE.
***
**/

short _declspec (dllexport)  WINAPI IMNBFinishSend ( short nOpNum )
{
    short         nCode;



    ShowDebugText ( "\nIMNB FinishSend " );



    /** Parameter validation: must have a valid SEND op number.
    **/

    if ( ValidateOpNumber ( nOpNum, IMNB_SEND ) == FALSE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }


    /** Has this operation finished yet? Check NCB command complete flag
    **/

    if ( NetOp [ nOpNum ].ncb_cmd_cplt == (BYTE) 0xFF ) {

        ShowDebugText ( "- still pending" );

        return ( IMNB_OP_IN_PROGRESS );     /* not yet ready */
    }


    nCode = NetOp [ nOpNum ].ncb_retcode;       /* get NetBIOS ret code */


    // Free the private buffer used by NetBIOS.

    GlobalFreePtr ( NetOp [ nOpNum ].ncb_buffer );


    if ( nCode != OK ) {                  /* If we have error code */

         nCode += IMNB_ERROR_BASE;     /* adjust to IMNB err code */
    }

	NetOp [ nOpNum ].nUser = OP_NOT_IN_USE;        /* release NCB */

    return ( ShowDebugRetCode ( nCode ) );
}






/**  This disconnects one of our sessions, using the NetBIOS HANGUP command.
***  For the possible consequences of this while transfers are in progress,
***  see the IBM NetBIOS Appl. Development Guide. As with other funcs in this
***  file, there is a corresponding IMNBFinishDisconnection call to get the
***  results.
**/

short _declspec (dllexport)  WINAPI IMNBDisconnectSession ( short nNetUser, short nSession, short  *lpnOpNum )
{
	short	      nCode;
    static short  nOp;



    if ( nDebugMode > 0 ) {         /* Display info if debugging */

        wsprintf ( szDebugTxt, "\nIMNB Disconct sess %d by ", nSession );
        ShowDebugText ( szDebugTxt );
	}


    *lpnOpNum = BAD_OP_NUM;        	 /* op NOT running yet */



    /** Parameter validation: should have a valid, active user no,
    *** and ptr to 2 writable bytes.
    **/

    if ( ( nNetUser < 0 ) || ( nNetUser > MAX_USERS ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( NetUser [ nNetUser ].nStatus != USER_ACTIVE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( IsBadWritePtr ( lpnOpNum, 2 ) ) {

   		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }


    ShowDebugText ( NetUser [ nNetUser ].szName );   /* our own name */


	// Obtain an NCB:

    nCode = FindNetCtrlBlock ( nNetUser, &nOp );

    if ( nCode != OK ) {

            return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    /** Fill required fields of NCB for asynchronous HANG_UP cmnd:
    ***
    ***    COMMAND, LANA_NUM, LSN (session num), and POST_ADDR
    **/

    NetOp [ nOp ].ncb_command  = ( NCB_ASYNCH | NCB_HANGUP );
    NetOp [ nOp ].ncb_post     = (DWORD) NetBIOSIntHandler;
    NetOp [ nOp ].ncb_lsn      = (BYTE) nSession;
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nNetUser ].nLanAdapter;

    NetOp [ nOp ].wParam = IMNB_DISCONNECT;       /* type of notify msg */


    nCode = SubmitOperationToNetBIOS ( nOp );

    if ( nCode == OK ) {    	/* command accepted by NetBIOS */

   		*lpnOpNum = nOp;        	/* this is operation number */

    } else {    			/* command rejected by NetBIOS */

   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */
    }

	return ( ShowDebugRetCode ( nCode ) );
}







/**  Checks if session disconnection has completed, and if so retrieves the
***  completion code and frees the Net Ctrl Block.
**/

short _declspec (dllexport)  WINAPI IMNBFinishDisconnection ( short nOpNum )
{
    short   nCode;



    ShowDebugText ( "\nIMNB FinishDiscnct " );



    /** Parameter validation: must have a valid DISCONNECT op number.
    **/

    if ( ValidateOpNumber ( nOpNum, IMNB_DISCONNECT ) == FALSE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }


    /** Has this operation finished yet? Check NCB command complete flag
    **/

    if ( NetOp [ nOpNum ].ncb_cmd_cplt == (BYTE) 0xFF ) {

        ShowDebugText ( "- not finished" );

        return ( IMNB_OP_IN_PROGRESS );     /* not yet ready */
    }


    nCode = NetOp [ nOpNum ].ncb_retcode;     /* get NetBIOS ret code */

    if ( nCode != OK ) {                  /* if failed */

        nCode += IMNB_ERROR_BASE;     /* adjust to IMNB err code */
    }

	NetOp [ nOpNum ].nUser = OP_NOT_IN_USE;        /* release NCB */

    return ( ShowDebugRetCode ( nCode ) );
}






/**  This starts waiting for an incoming datagram addressed to the user's name,
***  using the NetBIOS RECEIVE-DATAGRAM command. There is NO TIMEOUT for this command -
***  it must either receive a datagram or be cancelled.
***
***  This function uses GlobalAllocPtr to create a FIXED page-locked buffer
***  large enough to hold the biggest expected block (given in wMaxSize).
***  Returns IMNB_OUT_OF_MEMORY if GlobalAlloc fails. When the notification
***  message is sent, the app calls IMNBFinishRecvDatagram to get the data that arrived,
***  and to copy it out into a user supplied buffer. At that point, we will free the
***  allocated buffer.
***
***  The receive-datagram op may be cancelled at any time (using IMNBCancelOp), but
***  you MUST still call IMNBFinishRecvDatagram afterwards to free the buffer and NCB.
**/

short _declspec (dllexport)  WINAPI IMNBRecvDatagram ( short nNetUser, WORD wMaxSize, short  *lpnOpNum )
{
	short	      nCode;
    void          * lpvBuffer;
    static short  nOp;



    ShowDebugText ( "\nIMNB RecvDgrm by " );


    *lpnOpNum = BAD_OP_NUM;        	 /* op NOT running yet */



    // Parameter validation: should have a valid, active user no and ptr to 2 writable bytes.

    if ( ( nNetUser < 0 ) || ( nNetUser > MAX_USERS ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( NetUser [ nNetUser ].nStatus != USER_ACTIVE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( IsBadWritePtr ( lpnOpNum, 2 ) ) {

   		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }

   	ShowDebugText ( NetUser [ nNetUser ].szName );	// Show name of caller for Debug


    // Obtain an NCB & Op number:

    nCode = FindNetCtrlBlock ( nNetUser, &nOp );

    if ( nCode != OK ) {

        return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    // Allocate a buffer to receive the data

    lpvBuffer = GlobalAllocPtr ( ( GMEM_FIXED | GMEM_ZEROINIT ), (DWORD) wMaxSize );

    if ( lpvBuffer == NULL ) {

   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

        ShowDebugText ( " - Failed to create data buf" );

    	return ( IMNB_OUT_OF_MEMORY );    /* no memory for buffer! */
    }


	/** Fill required fields of NCB for asynchronous RECEIVE_DATAGRAM:
    ***
    ***      COMMAND, LANA_NUM, NUM (our name number), BUFFER (ptr),
    ***      LENGTH (of buffer), and POST_ADDR
    **/

   	NetOp [ nOp ].ncb_command  = ( NCB_ASYNCH | NCB_RECVDG );
   	NetOp [ nOp ].ncb_num      = (BYTE) NetUser [ nNetUser ].nNameNumber;
    NetOp [ nOp ].ncb_post     = (DWORD) NetBIOSIntHandler;
    NetOp [ nOp ].ncb_buffer   = lpvBuffer;
    NetOp [ nOp ].ncb_length   = wMaxSize;
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nNetUser ].nLanAdapter;

    NetOp [ nOp ].wParam = IMNB_RECVDATAGRAM;    // type of notify msg


    nCode = SubmitOperationToNetBIOS ( nOp );

    if ( nCode == OK ) {    	/* command accepted by NetBIOS */

   		*lpnOpNum = nOp;        	/* this is operation number */

    } else {    			/* command rejected by NetBIOS */

   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

    	GlobalFreePtr ( lpvBuffer );       /* free the data buffer */
    }

	return ( ShowDebugRetCode ( nCode ) );
}






/**  SEE FUNCTION ABOVE.
***
**/

short _declspec (dllexport)  WINAPI IMNBFinishRecvDatagram ( short nOpNum, LPVOID lpvBuffer, LPWORD lpwActualSize,
					       																  LPSTR lpszSender )
{
    short		nCode, nUser;
    static char	szTemp [ 20 ];



    ShowDebugText ( "\nIMNB FinishRcvDrgm " );



    /** Parameter validation: must have a valid RECVDATAGRAM op number; a
    *** ptr to writable bytes for data buffer; ptr to 2 writable bytes
    *** for actual size; and ptr to 17 writable bytes for sender's name (unless NULL).
    **/

    if ( ValidateOpNumber ( nOpNum, IMNB_RECVDATAGRAM ) == FALSE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }

	if ( IsBadWritePtr ( lpvBuffer, 1 ) ||
         IsBadWritePtr ( lpwActualSize, 2 ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }

    if ( lpszSender != NULL ) {

		if ( IsBadWritePtr ( lpszSender, 17 ) ) {
	
        	return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
        }
    }


    /** Has this operation finished yet? Check NCB command complete flag
    **/

    if ( NetOp [ nOpNum ].ncb_cmd_cplt == (BYTE) 0xFF ) {

        ShowDebugText ( "- still pending" );

        return ( IMNB_OP_IN_PROGRESS );     /* not yet ready */
    }


    nCode = NetOp [ nOpNum ].ncb_retcode;       /* get NetBIOS ret code */

    *lpwActualSize = NetOp [ nOpNum ].ncb_length;   /* amount data recd */

    if ( lpszSender != NULL ) {

		TranslateNBNameToC ( NetOp [ nOpNum ].ncb_callname, lpszSender );
    }


    // Copy the received data out of the buffer used by
    // NetBIOS into the user's buffer. Then free the NetBIOS buffer.

    memcpy ( lpvBuffer, NetOp [ nOpNum ].ncb_buffer, *lpwActualSize );

    GlobalFreePtr ( NetOp [ nOpNum ].ncb_buffer );


	// If debugging mode selected, display some info about results

    if ( nDebugMode > 0 ) {

		TranslateNBNameToC ( NetOp [ nOpNum ].ncb_callname, szTemp );

        nUser = NetOp [ nOpNum ].nUser;

        wsprintf ( szDebugTxt, "%s rcvd %u bytes from %s", (LPCSTR) NetUser [ nUser ].szName,
        									 							*lpwActualSize, (LPCSTR) szTemp );
        ShowDebugText ( szDebugTxt );
	}

    if ( nCode != OK ) {

        nCode += IMNB_ERROR_BASE;     /* adjust to IMNB err code */
    }

	NetOp [ nOpNum ].nUser = OP_NOT_IN_USE;        /* release NCB */

    return ( ShowDebugRetCode ( nCode ) );
}





/**  IMNBTransmitDatagram is the partner to IMNBRecvDatagram. Caller must supply the NetBIOS name
***  to send it to (either unique or GROUP name), pointer to the memory buffer to be sent,
***  and a size (limited by implementation - typically 512 or 1024 bytes).
***
***  THIS ACTION IS SYNCHRONOUS - COMPLETES BEFORE RETURNING TO CALLING APP.
***
***  Therefore, there is no notification message, and no finish function.
***
***  If anyone using the correct name has a RecvDatagram operation pending, they will receive
***  this datagram. If not, the data is lost. The caller cannot tell how many other apps, if any,
***  actually received it - it is completely unacknowledged. Happens immediately so no timeout.
***
***  The max size supported may vary from system to system - look for error IMNB_BAD_BUF_SIZE.
**/

short _declspec (dllexport)  WINAPI IMNBTransmitDatagram ( short nNetUser, LPCSTR lpszDestName, LPVOID lpvBuffer,
																								 WORD wSize )
{
	short	      nCode;
    static short  nOp;


    ShowDebugText ( "\nIMNB TransmitDgrm " );


    /** Parameter validation: should have a valid, active user no,
    *** ptr to wSize readable data bytes and ptr to at least 2 readable bytes for name.
    **/

    if ( ( nNetUser < 0 ) || ( nNetUser > MAX_USERS ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( NetUser [ nNetUser ].nStatus != USER_ACTIVE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( IsBadReadPtr ( lpszDestName, 2 ) ||
         IsBadReadPtr ( lpvBuffer, wSize ) ) {

   		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }


    if ( nDebugMode > 0 ) {         /* Display info if debugging */

        wsprintf ( szDebugTxt, "%s transmits %u bytes to %s", (LPCSTR) NetUser [ nNetUser ].szName,
        						 												wSize, lpszDestName );
        ShowDebugText ( szDebugTxt );
	}


	// Obtain an NCB:

    nCode = FindNetCtrlBlock ( nNetUser, &nOp );

    if ( nCode != OK ) {

        return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    // Since we are doing this call synchronously i.e. using NetBIOS WAIT option to force operation
    // to complete before the call returns to us, we do not need to duplicate the data in a separate
    // buffer.


	/** Fill required fields of NCB for synchronous SEND-DATAGRAM:
    ***
    ***      COMMAND, LANA_NUM, NUM (our name number), CALLNAME, BUFFER (ptr), LENGTH (of buffer)
    **/

   	NetOp [ nOp ].ncb_command  = NCB_SENDDG;		// No Async flag
   	NetOp [ nOp ].ncb_num      = (BYTE) NetUser [ nNetUser ].nNameNumber;
    NetOp [ nOp ].ncb_buffer   = lpvBuffer;
    NetOp [ nOp ].ncb_length   = wSize;
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nNetUser ].nLanAdapter;

   	TranslateCNameToNB ( lpszDestName, NetOp [ nOp ].ncb_callname );

    nCode = SubmitOperationToNetBIOS ( nOp );


	NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

	return ( ShowDebugRetCode ( nCode ) );
}







/**  This removes the NetBIOS name for the specified "user" from the local
***  NetBIOS name table. When this has completed (via IMNBFinishDeregistraton)
***  the user is effectively "logged off" the network and can only resume
***  by making a new call to IMNBRegisterName. For the possible consequences
***  of this while transfers are in progress, see the IBM NetBIOS Applic.
***  Development Guide.
**/

short _declspec (dllexport)  WINAPI IMNBDeregister ( short nNetUser, short  *lpnOpNum )
{
	short	      nCode;
    static short  nOp;



    ShowDebugText ( "\nIMNB DeReg " );


    *lpnOpNum = BAD_OP_NUM;        	 /* op NOT running yet */


    /** Parameter validation: should have a valid, active user no, and
    *** ptr to 2 writable bytes.
    **/

    if ( ( nNetUser < 0 ) || ( nNetUser > MAX_USERS ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

    if ( NetUser [ nNetUser ].nStatus != USER_ACTIVE ) {

        return ( ShowDebugRetCode ( IMNB_BAD_USER_NUM ) );
    }

	if ( IsBadWritePtr ( lpnOpNum, 2 ) ) {

   		return ( ShowDebugRetCode ( IMNB_BAD_POINTER ) );
    }


    ShowDebugText ( NetUser [ nNetUser ].szName );   /* show for debug */


	// Prepare an NCB for the DELETE_NAME operation:

    nCode = FindNetCtrlBlock ( nNetUser, &nOp );

    if ( nCode != OK ) {

        return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    /** Fill required fields of NCB for asynchronous DELETE_NAME cmnd:
    ***
    ***  reqd fields:  COMMAND, LANA, NAME and POST_ADDR
    **/

    NetOp [ nOp ].ncb_command  = ( NCB_ASYNCH | NCB_DELNAME );
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nNetUser ].nLanAdapter;
    NetOp [ nOp ].ncb_post     = (DWORD) NetBIOSIntHandler;

    _fstrncpy ( NetOp [ nOp ].ncb_name, NetUser [ nNetUser ].szName, 16 );

    NetOp [ nOp ].wParam = IMNB_DEREGISTER;       /* type of notify msg */


    nCode = SubmitOperationToNetBIOS ( nOp );

    if ( nCode == OK ) {    	/* command accepted by NetBIOS */

   		*lpnOpNum = nOp;        /* this is operation number */

        NetUser [ nNetUser ].nStatus = USER_UNREGISTERING;

    } else {    			/* command rejected by NetBIOS */

   		NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */
    }

	return ( ShowDebugRetCode ( nCode ) );
}





/**  SEE FUNCTION ABOVE.
***
**/

short _declspec (dllexport)  WINAPI IMNBFinishDeregistration ( short nOpNum )
{
    short   nCode, nUser;



    ShowDebugText ( "\nIMNB FinishDeReg" );



    /** Parameter validation: must be a valid DEREG operation.
    **/

    if ( ValidateOpNumber ( nOpNum, IMNB_DEREGISTER ) == FALSE ) {

            return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }


	nUser = NetOp [ nOpNum ].nUser;         /* find NetUser struct */


    /** Has this operation finished yet? Check NCB command complete flag
    **/

    if ( NetOp [ nOpNum ].ncb_cmd_cplt == (BYTE) 0xFF ) {

        ShowDebugText ( " - still pending" );

        return ( IMNB_OP_IN_PROGRESS );     /* not yet ready */
    }


    nCode = NetOp [ nOpNum ].ncb_retcode;       /* get NetBIOS ret code */

    if ( nCode == OK ) {            /* Successfully Deleted name */

		NetUser [ nUser ].nStatus    = USER_FREE;    /* no user   */
		NetUser [ nUser ].hWndNotify = NULL;         /* no window */

	} else {                /* Failed to delete name */

		nCode += IMNB_ERROR_BASE;       /* adjust to IMNB err code */

		NetUser [ nUser ].nStatus = USER_ACTIVE;     /* Not gone! */
    }

	NetOp [ nOpNum ].nUser = OP_NOT_IN_USE;        /* release NCB */

    return ( ShowDebugRetCode ( nCode ) );
}





/**  This cancels the specified operation:
***     Register        - CANNOT be cancelled
***  	Listen          - can be cancelled safely
***		Call            - can be cancelled safely
***		ReceiveData     - can be cancelled safely
***     SendData        - can be cancelled, but the session will be killed!!
***     Disconnect      - can be cancelled
***     RecvDatagram    - can be cancelled safely
***		TransmitDatagam - completes in a single synchronous call, so CANNOT be cancelled
***     DeRegister      - CANNOT be cancelled
***
*** NOTE 1: It might be too late to cancel an operation - may already have
***   happened. In this case, this func returns IMNB_ALREADY_COMPLETED.
***
*** NOTE 2: You MUST still call the normal IMNBFinish... func after cancelling
***   because only these Finish funcs free buffers and structures, both
***   within this file and inside NetBIOS itself.
***
***  This command is synchronous - will wait for completion before returning.
**/

short _declspec (dllexport)  WINAPI IMNBCancelOp ( short nOpNum )
{
	short	      nCode, nUser;
    static short  nOp;



    ShowDebugText ( "\nIMNB Cancel by " );


    // Parameter validation: should have a pending operation with a known user.

    if ( ( nOpNum < 0 ) || ( nOpNum >= MAX_OPS ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }


    nUser = NetOp [ nOpNum ].nUser;         /* find user of this op */

    if ( ( nUser < 0 ) || ( nUser >= MAX_USERS ) ) {

        return ( ShowDebugRetCode ( IMNB_BAD_OP_NUM ) );
    }


    ShowDebugText ( NetUser [ nUser ].szName );


	/** Prepare an NCB for the CANCEL operation itself:
	**/

    nCode = FindNetCtrlBlock ( nUser, &nOp );

    if ( nCode != OK ) {

        return ( ShowDebugRetCode ( nCode ) ); 	   /* too many ops */
    }


    /** Fill required fields of NCB for SYNCHRONOUS CANCEL cmnd:
    ***
    ***   COMMAND, LANA, BUFFER (ptr to NCB to cancel)
    ***
    *** This command is synchronous - will wait for completion before
    *** returning from SubmitOperationToNetBIOS. No post interrupt.
    **/

    NetOp [ nOp ].ncb_command  = NCB_CANCEL;
    NetOp [ nOp ].ncb_lana_num = (BYTE) NetUser [ nUser ].nLanAdapter;
    NetOp [ nOp ].ncb_post     = (DWORD) 0;         /* no post intrpt */
    NetOp [ nOp ].ncb_buffer   = &( NetOp [ nOpNum ].ncb_command );


    nCode = SubmitOperationToNetBIOS ( nOp );


	NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

	return ( ShowDebugRetCode ( nCode ) );
}





/**  DEBUGGING TOOL:
***
***  This carries out a NetBIOS SESSION_STATUS command and puts the returned
***  info into the specified buffer. This is for diagnostic purposes only -
***  it shows number of sessions, number of pending sends & receives, etc.
***  See NetBIOS reference manuals. Synchronous.
**/

short _declspec (dllexport)  WINAPI IMNBGetStatus ( short nLAN, LPCSTR lpszName, LPVOID lpvBuffer, short nMaxSize )
{
	short	      nCode;
    static short  nOp;




    /** Parameter validation: should have ptr to a readable name,
    *** and ptr to writable buffer of stated size.
    **/

    if ( IsBadReadPtr ( lpszName, 2 ) ||
         IsBadWritePtr ( lpvBuffer, nMaxSize ) ) {

   		return ( IMNB_BAD_POINTER );
    }


	/** Prepare an NCB for the SESSION_STATUS operation:
	**/

    nCode = FindNetCtrlBlock ( 0, &nOp );       /* no particular user */

    if ( nCode != OK ) {

        return ( nCode ); 	   /* too many ops */
    }


    /** Fill required fields of NCB for SYNCHRONOUS SESSION_STATUS cmnd:
    ***
    ***   COMMAND, LANA, BUFFER, LENGTH, NAME
    ***
    *** This command is synchronous - will wait for completion before
    *** returning from SubmitOperationToNetBIOS. No post interrupt.
    **/

    NetOp [ nOp ].ncb_command  = NCB_SESSSTAT;
    NetOp [ nOp ].ncb_lana_num = (BYTE) nLAN;
    NetOp [ nOp ].ncb_buffer   = lpvBuffer;
    NetOp [ nOp ].ncb_length   = (WORD) nMaxSize;
    NetOp [ nOp ].ncb_post     = (DWORD) 0;       /* no post interrupt */

	TranslateCNameToNB ( lpszName, NetOp [ nOp ].ncb_name );

    nCode = SubmitOperationToNetBIOS ( nOp );

	NetOp [ nOp ].nUser = OP_NOT_IN_USE;        /* release NCB */

    return ( nCode );
}





/**  This takes a ptr to a normal C string  and copies it to the other buffer
***  as a NetBIOS format name string - padded to EXACTLY 16 chars with
***  trailing spaces and NO terminating zero byte. The name should be 15
***  chars or fewer, because the last char needs to be a space for ordinary
***  names (other chars in last position signify special types of name, by
***  Microsoft convention).
**/

void  TranslateCNameToNB ( LPCSTR lpszCName, LPSTR lpszNBName )
{
    short   nChar;


    _fstrncpy ( lpszNBName, lpszCName, 16 );

	nChar = 15;             	/* check for trailing null bytes */

    while ( lpszNBName [ nChar ] == 0 ) {

            lpszNBName [ nChar ] = ' ';     /* pad with space char */

            nChar--;
    }

    return;
}




/**  This is the reverse of the func above - transfers a NetBIOS format
***  name into an ordinary C string (see above).
**/

void  TranslateNBNameToC ( LPCSTR lpszNBName, LPSTR lpszCName )
{
    short   nChar;


    _fstrncpy ( lpszCName, lpszNBName, 16 );

	lpszCName [ 16 ] = 0;           /* terminate C string */

	nChar = 15;             	/* check for trailing spaces */

    while ( lpszCName [ nChar ] == ' ' ) {

        lpszCName [ nChar ] = 0;     /* pad with zero bytes */

        nChar--;
    }

    return;
}




/**  This finds a free NetOp structure, flags it as belonging to this user,
***  then clears the contents ready for use and returns the index into the
***  NetOp array. This is the standard way all the functions above obtain
***  their NCBs.
***
***  NOTE: There is NO matching release function - simply do this when finished:
***
*** 		NetOp [ nOp ].nUser = OP_NOT_IN_USE;
***
**/

short FindNetCtrlBlock ( short nUser, short *pnOp )
{
	short   nOp;



	/** Search the NetOp array for an NCB which is not currently in use:
	**/

	for ( nOp = 0; nOp < MAX_OPS; nOp++ ) {

		if ( NetOp [ nOp ].nUser == OP_NOT_IN_USE ) {

            break;  	/* use this one */
        }

        if ( nOp == ( MAX_OPS - 1 ) ) {

			return ( IMNB_TOO_MANY_OPS );     /* non free */
        }
	}


    /** Now mark this structure as belonging to us and clear out the
    *** NCB section to all zeros (recommended in NetBIOS spec):
    **/

    NetOp [ nOp ].nUser = nUser;

    memset ( &( NetOp [ nOp ].ncb_command ), 0, NUM_BYTES_IN_NCB );

    *pnOp = nOp;		/* Here is your NCB pointer */

    return ( OK );
}







/**  This is called by the NetFinish... funcs to check if the OpNum they have
***  been given is valid. It perfoms three simple tests:
***     - is the number within range? (Can safely index NetOp array)
***     - is this NCB in use?
***     - is it doing the correct type of operation?
***
***  Returns TRUE if OK or FALSE if OpNum is wrong. This will safely filter
***  out corrupted or erroneous calls without crashing/corrupting everything.
**/

BOOL ValidateOpNumber ( short nOpNum, WORD wType )
{

    if ( ( nOpNum < 0 ) || ( nOpNum >= MAX_OPS ) ) {

        return ( FALSE );       /* out of range */
    }

    if ( NetOp [ nOpNum ].nUser == OP_NOT_IN_USE ) {

        return ( FALSE );       /* no known user for this op */
    }

    if ( NetOp [ nOpNum ].wParam != wType ) {

        return ( FALSE );       /* wrong type of op */
    }

    return ( TRUE );        /* seems OK */
}





/**  This is the actual interface to NetBIOS itself. Caller simply passes
***  in the index to the NetOp array showing which structure has the NCB
***  fully setup and ready to be executed. This function obtains a segment
***  and offset pointer to the NCB portion of the structure, loads the
***  ES:BX registers and calls NetBIOSCall (equivalent to INT 5Ch). It
***  extracts the immediate return code from AX, and adjusts to IMNB_...
***  error code if non-zero, by adding IMNB_ERROR_BASE (=3000).
**/

short SubmitOperationToNetBIOS ( short nOp )
{
	short		nCode;


    // Obtain pointer to the start of the NetBIOS NCB structure and pass this to Win32 API

	nCode = Netbios ( (PNCB) &( NetOp [ nOp ].ncb_command ) );

    
    // Finally adjust error code. If it is 0 (no problem) then it stays the same (OK = 0).
    // If non-zero, adjust the raw NetBIOS error (1..255) into IMNBLIB error value (3001..3255).

    if ( nCode != OK ) {    		/* if non-zero error code */

        nCode += IMNB_ERROR_BASE;       /* map onto IMNBLIB error */
    }

	return ( nCode );
}





/**  Interrupt Handler.
***
***  This is called when an asynchronous NetBIOS operation completes - either
***  successfully or when it fails. ES:BX points to the relevant NCB. SInce
***  this code is executed at interrupt time, the only Windows API func
***  we can safely use is PostMessage. The routine simply works out which
***  window (if any) to post a message to, and puts in the correct message
***  parameters, as described in IMNBLIB-FS.
**/

void CALLBACK  NetBIOSIntHandler ( PNCB NetCtrlBlock )
{
    short   nIndex, nUser;


    /** When called by NetBIOS, argument points to the NCB which has
    *** just completed. We must scan our list of pending NCBs to find
    *** our operation number for this NCB.
    **/

    for ( nIndex = 0; nIndex < MAX_OPS; nIndex++ ) {

        if ( ((PNCB) &( NetOp [ nIndex ].ncb_command )) == NetCtrlBlock ) {

            break;          /* This op has completed */
        }

        if ( nIndex == ( MAX_OPS - 1 ) ) {

            // We have hit the end of our list of NCBs and none of them match. This shouldn't happen!

		    ShowDebugText ( "\nIMNB Completion of unknown op!" );

            return;         /* unknown NCB */
        }
    }


    nUser = NetOp [ nIndex ].nUser;

    if ( nUser == OP_NOT_IN_USE ) {

            // This operation is not owned by any user. Again, this should never happen.

		    ShowDebugText ( "\nIMNB Completion of op without owner!" );

            return;         /* Owner of NCB not known */
    }


    // We know who the owner of this NCB is. If they have given us
    // a window handle, we will send it the message they want.

    if ( NetUser [ nUser ].hWndNotify != NULL ) {

		PostMessage ( NetUser [ nUser ].hWndNotify,
            	      NetUser [ nUser ].wNotifyMsg,
                      MAKEWPARAM ( NetOp [ nIndex ].wParam, 0 ),
                      MAKELPARAM ( nIndex, 0 ) );
	}

    return;
}






/**  This is called by the exported functions above to produce debugging text
***  output. If nDebugMode is zero (off), nothing happens, else the string
***  is passed to OutputDebugString.
**/

void  ShowDebugText ( LPCSTR szText )
{

    if ( nDebugMode > 0 ) {         /* output only if Mode > 0 */

        OutputDebugString ( szText );
    }

    return;
}




/**  Very similar to above, but in this func an error number is passed in.
***  If debug output is enabled, this produces a message like "OK" or
***  "Error 3022" etc. Returns its argument value.
**/

short ShowDebugRetCode ( short nCode )
{
    static char    szText [ 20 ];


    if ( nDebugMode > 0 ) {         /* output only if Mode > 0 */

        if ( nCode == OK ) {

            OutputDebugString ( " OK" );
        } else {
        	OutputDebugString ( " Error " );
        	OutputDebugString ( _itoa ( nCode, szText, 10 ) );
        }
    }

    return ( nCode );
}
